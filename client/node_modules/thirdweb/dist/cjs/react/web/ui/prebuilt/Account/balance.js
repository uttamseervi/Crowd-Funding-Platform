"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountBalance = AccountBalance;
exports.loadAccountBalance = loadAccountBalance;
exports.formatAccountTokenBalance = formatAccountTokenBalance;
exports.formatAccountFiatBalance = formatAccountFiatBalance;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_query_1 = require("@tanstack/react-query");
const addresses_js_1 = require("../../../../../constants/addresses.js");
const pay_js_1 = require("../../../../../exports/pay.js");
const useActiveWalletChain_js_1 = require("../../../../../react/core/hooks/wallets/useActiveWalletChain.js");
const address_js_1 = require("../../../../../utils/address.js");
const formatNumber_js_1 = require("../../../../../utils/formatNumber.js");
const shortenLargeNumber_js_1 = require("../../../../../utils/shortenLargeNumber.js");
const getWalletBalance_js_1 = require("../../../../../wallets/utils/getWalletBalance.js");
const provider_js_1 = require("./provider.js");
/**
 * This component fetches and shows the balance of the wallet address on a given chain.
 * It inherits all the attributes of a HTML <span> component, hence you can style it just like how you would style a normal <span>
 *
 *
 * @example
 * ### Basic usage
 * ```tsx
 * import { AccountProvider, AccountBalance } from "thirdweb/react";
 * import { ethereum } from "thirdweb/chains";
 *
 * <AccountProvider address="0x...">
 *   <AccountBalance chain={ethereum} />
 * </AccountProvider>
 * ```
 * Result:
 * ```html
 * <span>1.091435 ETH</span>
 * ```
 *
 *
 * ### Format the balance (round up, shorten etc.)
 * The AccountBalance component accepts a `formatFn` which takes in an object of type `AccountBalanceInfo` and outputs a string
 * The function is used to modify the display value of the wallet balance (either in crypto or fiat)
 *
 * ```tsx
 * import type { AccountBalanceInfo } from "thirdweb/react";
 * import { formatNumber } from "thirdweb/utils";
 *
 * const format = (props: AccountInfoBalance):string => `${formatNumber(props.balance, 1)} ${props.symbol.toLowerCase()}`
 *
 * <AccountBalance formatFn={format} />
 * ```
 *
 * Result:
 * ```html
 * <span>1.1 eth</span> // the balance is rounded up to 1 decimal and the symbol is lowercased
 * ```
 *
 * ### Show a loading sign when the balance is being fetched
 * ```tsx
 * import { AccountProvider, AccountBalance } from "thirdweb/react";
 *
 * <AccountProvider address="0x...">
 *   <AccountBalance
 *     chain={ethereum}
 *     loadingComponent={<Spinner />}
 *   />
 * </AccountProvider>
 * ```
 *
 * ### Fallback to something when the balance fails to resolve
 * ```tsx
 * <AccountProvider address="0x...">
 *   <AccountBalance
 *     chain={nonExistentChain}
 *     fallbackComponent={"Failed to load"}
 *   />
 * </AccountProvider>
 * ```
 *
 * ### Custom query options for useQuery
 * This component uses `@tanstack-query`'s useQuery internally.
 * You can use the `queryOptions` prop for more fine-grained control
 * ```tsx
 * <AccountBalance
 *   queryOptions={{
 *     enabled: isEnabled,
 *     retry: 4,
 *   }}
 * />
 * ```
 *
 * @component
 * @wallet
 * @beta
 */
function AccountBalance({ chain, tokenAddress, loadingComponent, fallbackComponent, queryOptions, formatFn, showBalanceInFiat, ...restProps }) {
    const { address, client } = (0, provider_js_1.useAccountContext)();
    const walletChain = (0, useActiveWalletChain_js_1.useActiveWalletChain)();
    const chainToLoad = chain || walletChain;
    const balanceQuery = (0, react_query_1.useQuery)({
        queryKey: [
            "internal_account_balance",
            chainToLoad?.id || -1,
            address,
            { tokenAddress },
            showBalanceInFiat,
        ],
        queryFn: async () => loadAccountBalance({
            chain: chainToLoad,
            client,
            address,
            tokenAddress,
            showBalanceInFiat,
        }),
        retry: false,
        ...queryOptions,
    });
    if (balanceQuery.isLoading) {
        return loadingComponent || null;
    }
    if (!balanceQuery.data) {
        return fallbackComponent || null;
    }
    // Prioritize using the formatFn from users
    if (formatFn) {
        return (0, jsx_runtime_1.jsx)("span", { ...restProps, children: formatFn(balanceQuery.data) });
    }
    if (showBalanceInFiat) {
        return ((0, jsx_runtime_1.jsx)("span", { ...restProps, children: formatAccountFiatBalance({ ...balanceQuery.data, decimals: 0 }) }));
    }
    return ((0, jsx_runtime_1.jsx)("span", { ...restProps, children: formatAccountTokenBalance({
            ...balanceQuery.data,
            decimals: balanceQuery.data.balance < 1 ? 3 : 2,
        }) }));
}
/**
 * @internal Exported for tests
 */
async function loadAccountBalance(props) {
    const { chain, client, address, tokenAddress, showBalanceInFiat } = props;
    if (!chain) {
        throw new Error("chain is required");
    }
    if (tokenAddress &&
        tokenAddress?.toLowerCase() === addresses_js_1.NATIVE_TOKEN_ADDRESS.toLowerCase()) {
        throw new Error(`Invalid tokenAddress - cannot be ${addresses_js_1.NATIVE_TOKEN_ADDRESS}`);
    }
    if (!(0, address_js_1.isAddress)(address)) {
        throw new Error("Invalid wallet address. Expected an EVM address");
    }
    if (tokenAddress && !(0, address_js_1.isAddress)(tokenAddress)) {
        throw new Error("Invalid tokenAddress. Expected an EVM contract address");
    }
    const tokenBalanceData = await (0, getWalletBalance_js_1.getWalletBalance)({
        chain,
        client,
        address,
        tokenAddress,
    }).catch(() => undefined);
    if (!tokenBalanceData) {
        throw new Error(`Failed to retrieve ${tokenAddress ? `token: ${tokenAddress}` : "native token"} balance for address: ${address} on chainId:${chain.id}`);
    }
    if (showBalanceInFiat) {
        const fiatData = await (0, pay_js_1.convertCryptoToFiat)({
            fromAmount: Number(tokenBalanceData.displayValue),
            fromTokenAddress: tokenAddress || addresses_js_1.NATIVE_TOKEN_ADDRESS,
            to: showBalanceInFiat,
            chain,
            client,
        }).catch(() => undefined);
        if (fiatData === undefined) {
            throw new Error(`Failed to resolve fiat value for ${tokenAddress ? `token: ${tokenAddress}` : "native token"} on chainId: ${chain.id}`);
        }
        return {
            balance: fiatData?.result,
            symbol: new Intl.NumberFormat("en", {
                style: "currency",
                currency: showBalanceInFiat,
                minimumFractionDigits: 0,
                maximumFractionDigits: 0,
            })
                .formatToParts(0)
                .find((p) => p.type === "currency")?.value ||
                showBalanceInFiat.toUpperCase(),
        };
    }
    return {
        balance: Number(tokenBalanceData.displayValue),
        symbol: tokenBalanceData.symbol,
    };
}
/**
 * Format the display balance for both crypto and fiat, in the Details button and Modal
 * If both crypto balance and fiat balance exist, we have to keep the string very short to avoid UI issues.
 * @internal
 * Used internally for the Details button and the Details Modal
 */
function formatAccountTokenBalance(props) {
    const formattedTokenBalance = (0, formatNumber_js_1.formatNumber)(props.balance, props.decimals);
    return `${formattedTokenBalance} ${props.symbol}`;
}
/**
 * Used internally for the Details button and Details Modal
 * @internal
 */
function formatAccountFiatBalance(props) {
    const num = (0, formatNumber_js_1.formatNumber)(props.balance, props.decimals);
    // Need to keep them short to avoid UI overflow issues
    const formattedFiatBalance = (0, shortenLargeNumber_js_1.shortenLargeNumber)(num);
    return `${props.symbol}${formattedFiatBalance}`;
}
//# sourceMappingURL=balance.js.map